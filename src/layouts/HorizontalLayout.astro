---
import '../styles/global.css';
import '../styles/glassmorphism.css';
import '../styles/horizontal-scroll.css';
import '../styles/animations.css';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import Sidebar from '../components/Sidebar.astro';
import ScrollProgress from '../components/ScrollProgress.astro';

interface Props {
  title?: string;
  showHeader?: boolean;
  showFooter?: boolean;
}

const { 
  title = 'Glass Showcase - Horizontal Scrolling Experience',
  showHeader = true,
  showFooter = true
} = Astro.props;
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <meta name="description" content="Interactive glassmorphism showcase with horizontal scrolling navigation" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <title>{title}</title>
</head>
<body>
  <!-- App Layer Structure -->
  <ScrollProgress />
  {showHeader && <Header />}
  {showFooter && <Footer />}
  <Sidebar />
  
  <slot />
  
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #1a0b2e 0%, #271255 50%, #1a0b2e 100%);
      background-attachment: fixed;
    }
    
    .horizontal-scroll-container {
      display: flex;
      flex-direction: row;
      overflow-x: scroll;
      overflow-y: hidden;
      scroll-snap-type: none;
      scroll-behavior: auto;
      height: 100vh;
      width: 100vw;
      scrollbar-width: thin;
      position: fixed;
      top: 0;
      left: 0;
      -webkit-overflow-scrolling: touch;
      background: transparent;
    }
    
    /* Scrollbar hidden - see horizontal-scroll.css */
    .horizontal-scroll-container::-webkit-scrollbar {
      display: none;
    }
    
    /* Force horizontal layout with vertical overflow support */
    :global(.scroll-section) {
      min-width: 100vw !important;
      width: 100vw !important;
      min-height: 100vh !important;
      height: auto !important;
      max-height: 100vh !important;
      flex-shrink: 0 !important;
      scroll-snap-align: none !important;
      overflow-y: auto !important;
      overflow-x: hidden !important;
      -webkit-overflow-scrolling: touch !important;
      background: transparent !important;
    }
    
    /* Hide section scrollbars */
    :global(.scroll-section)::-webkit-scrollbar {
      display: none;
    }
    
    /* Mobile: vertical scroll */
    @media (max-width: 768px) {
      .horizontal-scroll-container {
        flex-direction: column;
        overflow-x: hidden;
        overflow-y: scroll;
        scroll-snap-type: y mandatory;
      }
      
      :global(.scroll-section) {
        min-height: 100vh !important;
        height: auto !important;
        min-width: 100vw !important;
        width: 100vw !important;
      }
    }
  </style>
  
  <script>
    import { gsap, ScrollTrigger } from '../utils/gsap-setup';
    
    // Wait for DOM to be ready
    document.addEventListener('DOMContentLoaded', () => {
      const container = document.querySelector('.horizontal-scroll-container');
      if (!container) return;
      
      const sections = document.querySelectorAll('.scroll-section');
      const navDots = document.querySelectorAll('.nav-dot');
      
      // Configure ScrollTrigger for horizontal scrolling
      ScrollTrigger.defaults({
        horizontal: true,
        scroller: '.horizontal-scroll-container'
      });
      
      // Enable smooth scrolling normalization
      ScrollTrigger.normalizeScroll(true);
      
      // Hybrid: Direct scroll + GSAP snap for best of both worlds
      let scrollTimeout = null;
      let isScrolling = false;
      
      // Smooth keyboard navigation with GSAP
      document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
          e.preventDefault();
          const direction = e.key === 'ArrowRight' ? 1 : -1;
          const currentScroll = container.scrollLeft;
          const sectionWidth = window.innerWidth;
          const currentIndex = Math.round(currentScroll / sectionWidth);
          const targetIndex = Math.max(0, Math.min(sections.length - 1, currentIndex + direction));
          
          // GSAP smooth scroll to target section
          gsap.to(container, {
            scrollLeft: targetIndex * sectionWidth,
            duration: 0.8,
            ease: 'power3.inOut'
          });
        }
      });
      
      container.addEventListener('wheel', (e) => {
        const currentScroll = container.scrollLeft;
        const sectionWidth = window.innerWidth;
        const currentIndex = Math.round(currentScroll / sectionWidth);
        const currentSection = sections[currentIndex];
        
        if (!currentSection) return;
        
        // Check if section has vertical overflow
        const hasVerticalOverflow = currentSection.scrollHeight > currentSection.clientHeight;
        
        if (hasVerticalOverflow && Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
          // Section has overflow and user is scrolling vertically
          const isAtTop = currentSection.scrollTop === 0;
          const isAtBottom = currentSection.scrollTop + currentSection.clientHeight >= currentSection.scrollHeight - 1;
          
          // Allow vertical scroll within section
          if ((e.deltaY > 0 && !isAtBottom) || (e.deltaY < 0 && !isAtTop)) {
            return;
          }
          
          // User is at top/bottom, smooth GSAP transition to next section
          e.preventDefault();
          
          if (!isScrolling) {
            isScrolling = true;
            
            if (e.deltaY > 0 && isAtBottom && currentIndex < sections.length - 1) {
              gsap.to(container, {
                scrollLeft: (currentIndex + 1) * sectionWidth,
                duration: 0.8,
                ease: 'power3.inOut',
                onComplete: () => { isScrolling = false; }
              });
            } else if (e.deltaY < 0 && isAtTop && currentIndex > 0) {
              gsap.to(container, {
                scrollLeft: (currentIndex - 1) * sectionWidth,
                duration: 0.8,
                ease: 'power3.inOut',
                onComplete: () => { isScrolling = false; }
              });
            } else {
              isScrolling = false;
            }
          }
        } else {
          // Hybrid approach: Direct scroll for responsiveness, GSAP for snap
          e.preventDefault();
          
          // Kill any active GSAP snap animations for immediate response
          gsap.killTweensOf(container);
          
          // Use raw delta for responsive feel on all screen sizes
          const rawDelta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
          const delta = rawDelta * 0.7; // Balanced multiplier
          
          // Direct, immediate scroll - no animation delays
          container.scrollBy({
            left: delta,
            behavior: 'auto' // Instant, no smoothing
          });
          
          // Snap to nearest section after scroll stops (GSAP for smooth alignment)
          clearTimeout(scrollTimeout);
          scrollTimeout = setTimeout(() => {
            const finalScroll = container.scrollLeft;
            const finalIndex = Math.round(finalScroll / sectionWidth);
            const targetScroll = finalIndex * sectionWidth;
            
            // Only snap if not already aligned
            if (Math.abs(targetScroll - finalScroll) > 1) {
              gsap.to(container, {
                scrollLeft: targetScroll,
                duration: 0.5, // Shorter for quicker response
                ease: 'power2.out' // Gentle easing
              });
            }
          }, 150); // Reduced from 180ms
        }
      }, { passive: false });
      
      // Enhanced touch swipe with velocity detection
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartTime = 0;
      let isSwiping = false;
      
      container.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
        touchStartTime = Date.now();
        isSwiping = false;
      }, { passive: true });
      
      container.addEventListener('touchmove', (e) => {
        if (!isSwiping) {
          const deltaX = Math.abs(e.changedTouches[0].screenX - touchStartX);
          const deltaY = Math.abs(e.changedTouches[0].screenY - touchStartY);
          
          // Determine if this is a horizontal swipe
          if (deltaX > deltaY && deltaX > 10) {
            isSwiping = true;
          }
        }
      }, { passive: true });
      
      container.addEventListener('touchend', (e) => {
        if (isSwiping) {
          const touchEndX = e.changedTouches[0].screenX;
          const touchEndTime = Date.now();
          const distance = touchStartX - touchEndX;
          const duration = touchEndTime - touchStartTime;
          const velocity = Math.abs(distance) / duration;
          
          // Swipe threshold adjusted for velocity
          const swipeThreshold = velocity > 0.5 ? 30 : 75;
          
          if (Math.abs(distance) > swipeThreshold) {
            const currentScroll = container.scrollLeft;
            const sectionWidth = window.innerWidth;
            const currentIndex = Math.round(currentScroll / sectionWidth);
            
            if (distance > 0 && currentIndex < sections.length - 1) {
              container.scrollTo({
                left: (currentIndex + 1) * sectionWidth,
                behavior: 'smooth'
              });
            } else if (distance < 0 && currentIndex > 0) {
              container.scrollTo({
                left: (currentIndex - 1) * sectionWidth,
                behavior: 'smooth'
              });
            }
          }
        }
      }, { passive: true });
      
      // Update active nav dot on horizontal scroll (if nav is visible)
      if (navDots.length > 0) {
        container.addEventListener('scroll', () => {
          const currentScroll = container.scrollLeft;
          const sectionWidth = window.innerWidth;
          const currentIndex = Math.round(currentScroll / sectionWidth);
          
          navDots.forEach((dot, index) => {
            if (index === currentIndex) {
              dot.classList.add('active');
            } else {
              dot.classList.remove('active');
            }
          });
        });
      }
      
      // Log scroll position for debugging
      container.addEventListener('scroll', () => {
        const currentScroll = container.scrollLeft;
        const maxScroll = container.scrollWidth - container.clientWidth;
        const progress = (currentScroll / maxScroll * 100).toFixed(1);
        console.log(`Scroll: ${currentScroll}px / ${maxScroll}px (${progress}%)`);
      });
      
      // Autohide with edge hover detection
      const header = document.getElementById('app-header');
      const sidebar = document.getElementById('app-sidebar');
      const footer = document.getElementById('app-footer');
      const sidebarOverlay = document.getElementById('sidebar-overlay');
      
      const HOVER_ZONE = 50; // pixels from edge
      const HOVER_DELAY = 100; // milliseconds before showing
      
      let headerTimer = null;
      let sidebarTimer = null;
      let footerTimer = null;
      
      // Track mouse position
      document.addEventListener('mousemove', (e) => {
        const { clientX, clientY } = e;
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        
        // Top edge - Header (available on all sections via hover)
        if (clientY < HOVER_ZONE) {
          clearTimeout(headerTimer);
          headerTimer = setTimeout(() => {
            header?.classList.add('show');
          }, HOVER_DELAY);
        } else if (clientY > 100) {
          clearTimeout(headerTimer);
          header?.classList.remove('show');
        }
        
        // Left edge - Sidebar
        if (clientX < HOVER_ZONE) {
          clearTimeout(sidebarTimer);
          sidebarTimer = setTimeout(() => {
            sidebar?.classList.add('show');
            sidebarOverlay?.classList.add('visible');
          }, HOVER_DELAY);
        } else if (clientX > 370) { // sidebar width + buffer
          clearTimeout(sidebarTimer);
          if (!sidebar?.classList.contains('open')) {
            sidebar?.classList.remove('show');
            sidebarOverlay?.classList.remove('visible');
          }
        }
        
        // Bottom edge - Footer
        if (clientY > windowHeight - HOVER_ZONE) {
          clearTimeout(footerTimer);
          footerTimer = setTimeout(() => {
            footer?.classList.add('show');
          }, HOVER_DELAY);
        } else if (clientY < windowHeight - 250) { // footer height + buffer
          clearTimeout(footerTimer);
          footer?.classList.remove('show');
        }
      });
      
      // Sidebar manual toggle (menu button and close)
      const menuToggle = document.getElementById('menu-toggle');
      const sidebarClose = document.getElementById('sidebar-close');
      
      function openSidebar() {
        sidebar?.classList.add('open', 'show');
        sidebarOverlay?.classList.add('visible');
        menuToggle?.classList.add('active');
      }
      
      function closeSidebar() {
        sidebar?.classList.remove('open', 'show');
        sidebarOverlay?.classList.remove('visible');
        menuToggle?.classList.remove('active');
      }
      
      menuToggle?.addEventListener('click', () => {
        if (sidebar?.classList.contains('open')) {
          closeSidebar();
        } else {
          openSidebar();
        }
      });
      
      sidebarClose?.addEventListener('click', closeSidebar);
      sidebarOverlay?.addEventListener('click', closeSidebar);
      
      // Close sidebar when clicking a link
      document.querySelectorAll('.sidebar-link').forEach(link => {
        link.addEventListener('click', closeSidebar);
      });
      
      // ========== PARALLAX EFFECTS ==========
      // Background parallax for all gradient sections (run after page load)
      setTimeout(() => {
        sections.forEach((section, index) => {
          // Parallax background movement - only if section has gradient
          if (section.classList.contains('gradient-radial-purple') || 
              section.classList.contains('gradient-radial-deep')) {
            gsap.to(section, {
              scrollTrigger: {
                trigger: section,
                start: 'left right',
                end: 'right left',
                scrub: 1,
                horizontal: true,
                scroller: '.horizontal-scroll-container',
                invalidateOnRefresh: true
              },
              backgroundPosition: '-15% center',
              ease: 'none'
            });
          }
          
          // Float glass demo cards with parallax - only for specific cards
          const glassCards = section.querySelectorAll('.glass-demo-card');
          glassCards.forEach((card, cardIndex) => {
            gsap.to(card, {
              scrollTrigger: {
                trigger: section,
                start: 'left right',
                end: 'right left',
                scrub: 2 + (cardIndex * 0.5),
                horizontal: true,
                scroller: '.horizontal-scroll-container',
                invalidateOnRefresh: true
              },
              y: -20 - (cardIndex * 5),
              rotation: cardIndex % 2 === 0 ? 2 : -2,
              ease: 'none'
            });
          });
        });
      }, 500);
      
      // ========== GSAP HOVER INTERACTIONS ==========
      // Enhanced glass button hovers
      document.querySelectorAll('.glass-button').forEach(btn => {
        const hoverTimeline = gsap.timeline({ paused: true });
        
        hoverTimeline
          .to(btn, { scale: 1.05, duration: 0.3, ease: 'power2.out' })
          .to(btn.querySelector('span'), { x: 5, duration: 0.3 }, '<')
          .to(btn, { 
            boxShadow: '0 8px 32px rgba(138, 43, 226, 0.4)',
            duration: 0.3 
          }, '<');
        
        btn.addEventListener('mouseenter', () => hoverTimeline.play());
        btn.addEventListener('mouseleave', () => hoverTimeline.reverse());
      });
      
      // 3D tilt effect for glass cards
      document.querySelectorAll('.glass-card:not(.menu-item), .glass-panel').forEach(card => {
        card.addEventListener('mousemove', (e) => {
          const rect = card.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          
          const rotateX = (y - centerY) / 10;
          const rotateY = (centerX - x) / 10;
          
          gsap.to(card, {
            rotationX: rotateX,
            rotationY: rotateY,
            duration: 0.5,
            ease: 'power2.out',
            transformPerspective: 1000,
            transformStyle: 'preserve-3d'
          });
        });
        
        card.addEventListener('mouseleave', () => {
          gsap.to(card, {
            rotationX: 0,
            rotationY: 0,
            duration: 0.5,
            ease: 'power2.out'
          });
        });
      });
      
      // ========== MAGNETIC CURSOR EFFECT ==========
      const buttons = document.querySelectorAll('.glass-button');
      
      buttons.forEach(button => {
        let isNearButton = false;
        
        const handleMouseMove = (e) => {
          const rect = button.getBoundingClientRect();
          const x = e.clientX - rect.left - rect.width / 2;
          const y = e.clientY - rect.top - rect.height / 2;
          
          const distance = Math.sqrt(x * x + y * y);
          const maxDistance = 100;
          
          if (distance < maxDistance) {
            if (!isNearButton) {
              isNearButton = true;
            }
            const strength = (maxDistance - distance) / maxDistance;
            gsap.to(button, {
              x: x * strength * 0.3,
              y: y * strength * 0.3,
              duration: 0.3,
              ease: 'power2.out'
            });
          } else if (isNearButton) {
            isNearButton = false;
            gsap.to(button, {
              x: 0,
              y: 0,
              duration: 0.5,
              ease: 'elastic.out(1, 0.5)'
            });
          }
        };
        
        const handleMouseLeave = () => {
          isNearButton = false;
          gsap.to(button, {
            x: 0,
            y: 0,
            duration: 0.5,
            ease: 'elastic.out(1, 0.5)'
          });
        };
        
        document.addEventListener('mousemove', handleMouseMove);
        button.addEventListener('mouseleave', handleMouseLeave);
      });
      
      // Log initial state for debugging
      console.log('App initialized:', {
        containerWidth: container.scrollWidth,
        viewportWidth: window.innerWidth,
        sections: sections.length,
        features: ['header overlay', 'sidebar', 'mouse wheel', 'keyboard', 'touch swipe', 'gsap animations'],
        gsapVersion: gsap.version
      });
      
      // ========== PERFORMANCE OPTIMIZATIONS ==========
      // Lazy loading: Refresh ScrollTrigger on window resize
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          ScrollTrigger.refresh();
        }, 250);
      });
      
      // Remove will-change after animations complete
      setTimeout(() => {
        document.querySelectorAll('.glass-card, .glass-panel, .effect-item').forEach(el => {
          el.classList.add('animated-complete');
        });
      }, 2000);
      
      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        ScrollTrigger.getAll().forEach(trigger => trigger.kill());
      });
      
      // ========== ANCHOR NAVIGATION ==========
      // Handle all anchor links with data-scroll-to attribute
      document.addEventListener('click', (e) => {
        const link = e.target.closest('a[data-scroll-to]');
        if (link) {
          e.preventDefault();
          const sectionIndex = parseInt(link.getAttribute('data-scroll-to'));
          const targetScroll = sectionIndex * window.innerWidth;
          
          // Close sidebar if open
          const sidebar = document.getElementById('app-sidebar');
          if (sidebar && sidebar.classList.contains('show')) {
            sidebar.classList.remove('show');
            document.getElementById('sidebar-overlay')?.classList.remove('active');
          }
          
          // Smooth scroll to section
          gsap.to(container, {
            scrollLeft: targetScroll,
            duration: 1.2,
            ease: 'power3.inOut'
          });
        }
      });
    });
  </script>
</body>
</html>
