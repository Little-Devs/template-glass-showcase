---
import '../styles/global.css';
import '../styles/glassmorphism.css';
import '../styles/horizontal-scroll.css';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import Sidebar from '../components/Sidebar.astro';

interface Props {
  title?: string;
  showHeader?: boolean;
  showFooter?: boolean;
}

const { 
  title = 'Glass Showcase - Horizontal Scrolling Experience',
  showHeader = true,
  showFooter = true
} = Astro.props;
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Interactive glassmorphism showcase with horizontal scrolling navigation" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <title>{title}</title>
</head>
<body>
  <!-- App Layer Structure -->
  {showHeader && <Header />}
  {showFooter && <Footer />}
  <Sidebar />
  
  <slot />
  
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #1a0b2e 0%, #271255 50%, #1a0b2e 100%);
      background-attachment: fixed;
    }
    
    .horizontal-scroll-container {
      display: flex;
      flex-direction: row;
      overflow-x: scroll;
      overflow-y: hidden;
      scroll-snap-type: none;
      scroll-behavior: auto;
      height: 100vh;
      width: 100vw;
      scrollbar-width: thin;
      position: fixed;
      top: 0;
      left: 0;
      -webkit-overflow-scrolling: touch;
      background: transparent;
    }
    
    /* Scrollbar hidden - see horizontal-scroll.css */
    .horizontal-scroll-container::-webkit-scrollbar {
      display: none;
    }
    
    /* Force horizontal layout with vertical overflow support */
    :global(.scroll-section) {
      min-width: 100vw !important;
      width: 100vw !important;
      min-height: 100vh !important;
      height: auto !important;
      max-height: 100vh !important;
      flex-shrink: 0 !important;
      scroll-snap-align: none !important;
      overflow-y: auto !important;
      overflow-x: hidden !important;
      -webkit-overflow-scrolling: touch !important;
      background: transparent !important;
    }
    
    /* Hide section scrollbars */
    :global(.scroll-section)::-webkit-scrollbar {
      display: none;
    }
    
    /* Mobile: vertical scroll */
    @media (max-width: 768px) {
      .horizontal-scroll-container {
        flex-direction: column;
        overflow-x: hidden;
        overflow-y: scroll;
        scroll-snap-type: y mandatory;
      }
      
      :global(.scroll-section) {
        min-height: 100vh !important;
        height: auto !important;
        min-width: 100vw !important;
        width: 100vw !important;
      }
    }
  </style>
  
  <script>
    import gsap from 'gsap';
    
    // Wait for DOM to be ready
    document.addEventListener('DOMContentLoaded', () => {
      const container = document.querySelector('.horizontal-scroll-container');
      if (!container) return;
      
      const sections = document.querySelectorAll('.scroll-section');
      const navDots = document.querySelectorAll('.nav-dot');
      
      // GSAP-powered ultra-smooth scrolling
      let scrollTimeout = null;
      let isScrolling = false;
      let accumulatedDelta = 0;
      
      // Create GSAP quickTo for instant responsive scrolling
      const quickScroll = gsap.quickTo(container, 'scrollLeft', {
        duration: 0.5,
        ease: 'power2.out'
      });
      
      // Smooth keyboard navigation with GSAP
      document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
          e.preventDefault();
          const direction = e.key === 'ArrowRight' ? 1 : -1;
          const currentScroll = container.scrollLeft;
          const sectionWidth = window.innerWidth;
          const currentIndex = Math.round(currentScroll / sectionWidth);
          const targetIndex = Math.max(0, Math.min(sections.length - 1, currentIndex + direction));
          
          // GSAP smooth scroll to target section
          gsap.to(container, {
            scrollLeft: targetIndex * sectionWidth,
            duration: 0.8,
            ease: 'power3.inOut'
          });
        }
      });
      
      container.addEventListener('wheel', (e) => {
        const currentScroll = container.scrollLeft;
        const sectionWidth = window.innerWidth;
        const currentIndex = Math.round(currentScroll / sectionWidth);
        const currentSection = sections[currentIndex];
        
        if (!currentSection) return;
        
        // Check if section has vertical overflow
        const hasVerticalOverflow = currentSection.scrollHeight > currentSection.clientHeight;
        
        if (hasVerticalOverflow && Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
          // Section has overflow and user is scrolling vertically
          const isAtTop = currentSection.scrollTop === 0;
          const isAtBottom = currentSection.scrollTop + currentSection.clientHeight >= currentSection.scrollHeight - 1;
          
          // Allow vertical scroll within section
          if ((e.deltaY > 0 && !isAtBottom) || (e.deltaY < 0 && !isAtTop)) {
            return;
          }
          
          // User is at top/bottom, smooth GSAP transition to next section
          e.preventDefault();
          
          if (!isScrolling) {
            isScrolling = true;
            
            if (e.deltaY > 0 && isAtBottom && currentIndex < sections.length - 1) {
              gsap.to(container, {
                scrollLeft: (currentIndex + 1) * sectionWidth,
                duration: 0.8,
                ease: 'power3.inOut',
                onComplete: () => { isScrolling = false; }
              });
            } else if (e.deltaY < 0 && isAtTop && currentIndex > 0) {
              gsap.to(container, {
                scrollLeft: (currentIndex - 1) * sectionWidth,
                duration: 0.8,
                ease: 'power3.inOut',
                onComplete: () => { isScrolling = false; }
              });
            } else {
              isScrolling = false;
            }
          }
        } else {
          // Ultra-smooth GSAP-powered horizontal scroll
          e.preventDefault();
          
          // Use raw delta for responsive feel on all screen sizes
          const rawDelta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
          const delta = rawDelta * 0.7; // Balanced multiplier for all screens
          
          // Accumulate delta for smoother continuous scrolling
          accumulatedDelta += delta;
          
          // Apply GSAP quickTo for buttery smooth scrolling
          const newScrollPos = currentScroll + delta;
          quickScroll(newScrollPos);
          
          // Snap to nearest section after scroll stops
          clearTimeout(scrollTimeout);
          scrollTimeout = setTimeout(() => {
            const finalScroll = container.scrollLeft;
            const finalIndex = Math.round(finalScroll / sectionWidth);
            const targetScroll = finalIndex * sectionWidth;
            
            // GSAP snap with smooth easing
            gsap.to(container, {
              scrollLeft: targetScroll,
              duration: 0.6,
              ease: 'power2.inOut'
            });
            
            accumulatedDelta = 0;
          }, 180);
        }
      }, { passive: false });
      
      // Enhanced touch swipe with velocity detection
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartTime = 0;
      let isSwiping = false;
      
      container.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
        touchStartTime = Date.now();
        isSwiping = false;
      }, { passive: true });
      
      container.addEventListener('touchmove', (e) => {
        if (!isSwiping) {
          const deltaX = Math.abs(e.changedTouches[0].screenX - touchStartX);
          const deltaY = Math.abs(e.changedTouches[0].screenY - touchStartY);
          
          // Determine if this is a horizontal swipe
          if (deltaX > deltaY && deltaX > 10) {
            isSwiping = true;
          }
        }
      }, { passive: true });
      
      container.addEventListener('touchend', (e) => {
        if (isSwiping) {
          const touchEndX = e.changedTouches[0].screenX;
          const touchEndTime = Date.now();
          const distance = touchStartX - touchEndX;
          const duration = touchEndTime - touchStartTime;
          const velocity = Math.abs(distance) / duration;
          
          // Swipe threshold adjusted for velocity
          const swipeThreshold = velocity > 0.5 ? 30 : 75;
          
          if (Math.abs(distance) > swipeThreshold) {
            const currentScroll = container.scrollLeft;
            const sectionWidth = window.innerWidth;
            const currentIndex = Math.round(currentScroll / sectionWidth);
            
            if (distance > 0 && currentIndex < sections.length - 1) {
              container.scrollTo({
                left: (currentIndex + 1) * sectionWidth,
                behavior: 'smooth'
              });
            } else if (distance < 0 && currentIndex > 0) {
              container.scrollTo({
                left: (currentIndex - 1) * sectionWidth,
                behavior: 'smooth'
              });
            }
          }
        }
      }, { passive: true });
      
      // Update active nav dot on horizontal scroll (if nav is visible)
      if (navDots.length > 0) {
        container.addEventListener('scroll', () => {
          const currentScroll = container.scrollLeft;
          const sectionWidth = window.innerWidth;
          const currentIndex = Math.round(currentScroll / sectionWidth);
          
          navDots.forEach((dot, index) => {
            if (index === currentIndex) {
              dot.classList.add('active');
            } else {
              dot.classList.remove('active');
            }
          });
        });
      }
      
      // Log scroll position for debugging
      container.addEventListener('scroll', () => {
        const currentScroll = container.scrollLeft;
        const maxScroll = container.scrollWidth - container.clientWidth;
        const progress = (currentScroll / maxScroll * 100).toFixed(1);
        console.log(`Scroll: ${currentScroll}px / ${maxScroll}px (${progress}%)`);
      });
      
      // Autohide with edge hover detection
      const header = document.getElementById('app-header');
      const sidebar = document.getElementById('app-sidebar');
      const footer = document.getElementById('app-footer');
      const sidebarOverlay = document.getElementById('sidebar-overlay');
      
      const HOVER_ZONE = 50; // pixels from edge
      const HOVER_DELAY = 100; // milliseconds before showing
      
      let headerTimer = null;
      let sidebarTimer = null;
      let footerTimer = null;
      
      // Track mouse position
      document.addEventListener('mousemove', (e) => {
        const { clientX, clientY } = e;
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        
        // Top edge - Header (available on all sections via hover)
        if (clientY < HOVER_ZONE) {
          clearTimeout(headerTimer);
          headerTimer = setTimeout(() => {
            header?.classList.add('show');
          }, HOVER_DELAY);
        } else if (clientY > 100) {
          clearTimeout(headerTimer);
          header?.classList.remove('show');
        }
        
        // Left edge - Sidebar
        if (clientX < HOVER_ZONE) {
          clearTimeout(sidebarTimer);
          sidebarTimer = setTimeout(() => {
            sidebar?.classList.add('show');
            sidebarOverlay?.classList.add('visible');
          }, HOVER_DELAY);
        } else if (clientX > 370) { // sidebar width + buffer
          clearTimeout(sidebarTimer);
          if (!sidebar?.classList.contains('open')) {
            sidebar?.classList.remove('show');
            sidebarOverlay?.classList.remove('visible');
          }
        }
        
        // Bottom edge - Footer
        if (clientY > windowHeight - HOVER_ZONE) {
          clearTimeout(footerTimer);
          footerTimer = setTimeout(() => {
            footer?.classList.add('show');
          }, HOVER_DELAY);
        } else if (clientY < windowHeight - 250) { // footer height + buffer
          clearTimeout(footerTimer);
          footer?.classList.remove('show');
        }
      });
      
      // Sidebar manual toggle (menu button and close)
      const menuToggle = document.getElementById('menu-toggle');
      const sidebarClose = document.getElementById('sidebar-close');
      
      function openSidebar() {
        sidebar?.classList.add('open', 'show');
        sidebarOverlay?.classList.add('visible');
        menuToggle?.classList.add('active');
      }
      
      function closeSidebar() {
        sidebar?.classList.remove('open', 'show');
        sidebarOverlay?.classList.remove('visible');
        menuToggle?.classList.remove('active');
      }
      
      menuToggle?.addEventListener('click', () => {
        if (sidebar?.classList.contains('open')) {
          closeSidebar();
        } else {
          openSidebar();
        }
      });
      
      sidebarClose?.addEventListener('click', closeSidebar);
      sidebarOverlay?.addEventListener('click', closeSidebar);
      
      // Close sidebar when clicking a link
      document.querySelectorAll('.sidebar-link').forEach(link => {
        link.addEventListener('click', closeSidebar);
      });
      
      // Log initial state for debugging
      console.log('App initialized:', {
        containerWidth: container.scrollWidth,
        viewportWidth: window.innerWidth,
        sections: sections.length,
        features: ['header overlay', 'sidebar', 'mouse wheel', 'keyboard', 'touch swipe']
      });
    });
  </script>
</body>
</html>
